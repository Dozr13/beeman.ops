diff -ruN /mnt/data/orig/packages/agent/package.json /mnt/data/inspect/packages/agent/package.json
--- /mnt/data/orig/packages/agent/package.json	2026-02-16 05:52:37.000000000 +0000
+++ /mnt/data/inspect/packages/agent/package.json	2026-02-21 22:37:00.082427292 +0000
@@ -3,8 +3,9 @@
   "private": true,
   "type": "module",
   "scripts": {
-    "dev": "tsx watch src/index.ts",
+    "dev": "tsx watch src/index.ts --",
     "typecheck": "tsc -p tsconfig.json --noEmit",
+    "hut:add": "tsx src/scripts/hutAdd.ts",
     "lint": "echo \"(wire eslint if you want)\""
   },
   "dependencies": {
diff -ruN /mnt/data/orig/packages/agent/src/collectors/hut/whatsminer.ts /mnt/data/inspect/packages/agent/src/collectors/hut/whatsminer.ts
--- /mnt/data/orig/packages/agent/src/collectors/hut/whatsminer.ts	2026-02-17 00:26:38.000000000 +0000
+++ /mnt/data/inspect/packages/agent/src/collectors/hut/whatsminer.ts	2026-02-21 22:34:25.105373524 +0000
@@ -57,7 +57,9 @@
   }>
 
   const ts = ctx.nowIso()
-  const siteCode = String((ctx.config as any)?.siteCode ?? 'SITE')
+  const cfgHut = String((ctx.config as any)?.hutCode ?? '').trim()
+  const prefix =
+    (ctx.hutCode ?? cfgHut) || String((ctx.config as any)?.siteCode ?? 'SITE')
 
   const devices: CollectorResult['devices'] = []
   const metrics: CollectorResult['metrics'] = []
@@ -70,7 +72,7 @@
         const loc = t.name ?? host
 
         // NEW externalId format: GH180.A01
-        const externalId = `${siteCode}.${loc}`
+        const externalId = `${prefix}.${loc}`
 
         devices.push({
           externalId,
diff -ruN /mnt/data/orig/packages/agent/src/index.ts /mnt/data/inspect/packages/agent/src/index.ts
--- /mnt/data/orig/packages/agent/src/index.ts	2026-02-20 18:11:03.770246964 +0000
+++ /mnt/data/inspect/packages/agent/src/index.ts	2026-02-21 22:33:43.619794326 +0000
@@ -26,6 +26,7 @@
 const cfg = loadConfig(CONFIG_PATH)
 
 // ---- Read config/env ----
+const hutCode = process.env.AGENT_HUT_CODE ?? cfg.hutCode ?? null
 const siteCode = process.env.AGENT_SITE_CODE ?? cfg.siteCode ?? 'DEV-SITE'
 const agentId = process.env.AGENT_ID ?? cfg.agentId ?? 'dev-agent'
 const apiUrl =
@@ -38,7 +39,8 @@
 const intervalSeconds = Number(cfg.intervalSeconds ?? 30)
 
 // Store queue in agent package dir so it doesn’t end up in random CWDs
-const queuePath = path.join(AGENT_PKG_DIR, `agent-${siteCode}.sqlite`)
+const queueKey = (hutCode ?? siteCode).replace(/[^a-zA-Z0-9._-]+/g, '_')
+const queuePath = path.join(AGENT_PKG_DIR, `agent-${queueKey}.sqlite`)
 const queue = createQueue(queuePath)
 
 const log = (msg: string, extra?: any) => {
@@ -67,7 +69,7 @@
   const ts = nowIso()
 
   const hb = HeartbeatBody.parse({
-    siteCode,
+    ...(hutCode ? { hutCode } : { siteCode }),
     agentId,
     ts,
     meta: {
@@ -80,6 +82,7 @@
 
   const ctx = {
     siteCode,
+    hutCode: hutCode ?? undefined,
     agentId,
     nowIso,
     log,
@@ -93,7 +96,7 @@
       externalId: `agent:${agentId}`,
       kind: 'AGENT' as const,
       name: `Agent ${agentId}`,
-      meta: { siteCode }
+      meta: { siteCode, ...(hutCode ? { hutCode } : {}) }
     },
     ...collected.devices
   ]
@@ -108,7 +111,7 @@
   ]
 
   const batch = IngestBatch.parse({
-    siteCode,
+    ...(hutCode ? { hutCode } : { siteCode }),
     agentId,
     devices,
     metrics
diff -ruN /mnt/data/orig/packages/agent/src/scripts/hutAdd.ts /mnt/data/inspect/packages/agent/src/scripts/hutAdd.ts
--- /mnt/data/orig/packages/agent/src/scripts/hutAdd.ts	1970-01-01 00:00:00.000000000 +0000
+++ /mnt/data/inspect/packages/agent/src/scripts/hutAdd.ts	2026-02-21 22:36:49.853689648 +0000
@@ -0,0 +1,136 @@
+import fs from 'node:fs'
+import path from 'node:path'
+
+type Args = {
+  hutCode: string
+  agentId?: string
+  apiUrl?: string
+  intervalSeconds?: number
+  assignSiteCode?: string
+  force?: boolean
+  bootstrap?: boolean
+}
+
+const parseArgs = (): Args => {
+  const argv = process.argv.slice(2)
+  const out: any = {}
+
+  const take = (k: string) => {
+    const i = argv.indexOf(k)
+    if (i < 0) return undefined
+    const v = argv[i + 1]
+    return v
+  }
+
+  const hutCode = argv.find((a) => !a.startsWith('-'))
+  if (!hutCode) {
+    console.error('Usage: hut:add <HUT_CODE> [--site <SITE_CODE>] [--agent <AGENT_ID>] [--api <API_URL>] [--interval <seconds>] [--bootstrap] [--force]')
+    process.exit(2)
+  }
+
+  out.hutCode = hutCode
+  out.assignSiteCode = take('--site')
+  out.agentId = take('--agent')
+  out.apiUrl = take('--api')
+
+  const intervalRaw = take('--interval')
+  if (intervalRaw) {
+    const n = Number(intervalRaw)
+    if (!Number.isFinite(n) || n <= 0) {
+      console.error(`Invalid --interval: ${intervalRaw}`)
+      process.exit(2)
+    }
+    out.intervalSeconds = n
+  }
+
+  out.bootstrap = argv.includes('--bootstrap')
+  out.force = argv.includes('--force')
+  return out as Args
+}
+
+const ensureDir = (dir: string) => {
+  fs.mkdirSync(dir, { recursive: true })
+}
+
+const writeConfig = (args: Args) => {
+  const repoRoot = process.cwd()
+  const cfgDir = path.join(repoRoot, 'packages', 'agent', 'config')
+  ensureDir(cfgDir)
+
+  const cfgPath = path.join(cfgDir, `${args.hutCode}.yml`)
+  if (fs.existsSync(cfgPath) && !args.force) {
+    console.error(`Config already exists: ${cfgPath} (use --force to overwrite)`)
+    process.exit(1)
+  }
+
+  const apiUrl = args.apiUrl ?? process.env.AGENT_API_URL ?? 'https://beeman-ops-api.onrender.com'
+  const intervalSeconds = args.intervalSeconds ?? 300
+  const agentId = args.agentId ?? `${args.hutCode.toLowerCase()}-agent-001`
+
+  const template = `# Auto-generated hut config\n# Fill in miners.targets with your IP mapping (A01.. etc).\n\n# Stable identity for this hut (recommended)\nhutCode: ${args.hutCode}\nagentId: ${agentId}\n\napi:\n  url: ${apiUrl}\n\nintervalSeconds: ${intervalSeconds}\n\ncollectors:\n  hut:\n    enabled: true\n\n    miners:\n      enabled: true\n\n      # Example:\n      # targets:\n      #   - name: A01\n      #     host: 192.168.1.101\n      #     port: 4028\n      targets: []\n\n      mockMiners:\n        enabled: false\n        count: 48\n\nwell:\n  enabled: false\n`
+
+  fs.writeFileSync(cfgPath, template, 'utf8')
+  console.log(`Wrote ${cfgPath}`)
+}
+
+const bootstrapApi = async (args: Args) => {
+  const apiUrl = args.apiUrl ?? process.env.AGENT_API_URL
+  if (!apiUrl) {
+    console.error('Missing --api <API_URL> (or AGENT_API_URL) for --bootstrap')
+    process.exit(2)
+  }
+
+  // 1) ensure hut exists
+  await fetch(`${apiUrl}/v1/huts`, {
+    method: 'POST',
+    headers: { 'content-type': 'application/json' },
+    body: JSON.stringify({ code: args.hutCode, name: args.hutCode })
+  }).catch(() => {
+    /* ignore if already exists or route differs */
+  })
+
+  if (!args.assignSiteCode) {
+    console.log('Bootstrap: hut created (or already exists). No --site provided, skipping assignment.')
+    return
+  }
+
+  // 2) find siteId by code
+  const sitesRes = await fetch(`${apiUrl}/v1/sites`)
+  if (!sitesRes.ok) {
+    console.error(`Failed to list sites: ${sitesRes.status}`)
+    process.exit(1)
+  }
+  const sites = (await sitesRes.json()) as Array<{ id: string; code: string }>
+  const site = sites.find((s) => s.code === args.assignSiteCode)
+  if (!site) {
+    console.error(`Site not found: ${args.assignSiteCode}`)
+    process.exit(1)
+  }
+
+  // 3) assign hut -> site
+  const assignRes = await fetch(
+    `${apiUrl}/v1/huts/by-code/${encodeURIComponent(args.hutCode)}/assign`,
+    {
+      method: 'POST',
+      headers: { 'content-type': 'application/json' },
+      body: JSON.stringify({ siteId: site.id })
+    }
+  )
+
+  if (!assignRes.ok) {
+    console.error(`Failed to assign hut: ${assignRes.status}`)
+    process.exit(1)
+  }
+  console.log(`Assigned hut ${args.hutCode} -> site ${args.assignSiteCode}`)
+}
+
+const main = async () => {
+  const args = parseArgs()
+  writeConfig(args)
+  if (args.bootstrap) await bootstrapApi(args)
+}
+
+main().catch((e) => {
+  console.error(String(e?.message ?? e))
+  process.exit(1)
+})
diff -ruN /mnt/data/orig/packages/agent/src/types.ts /mnt/data/inspect/packages/agent/src/types.ts
--- /mnt/data/orig/packages/agent/src/types.ts	2026-02-16 08:34:04.000000000 +0000
+++ /mnt/data/inspect/packages/agent/src/types.ts	2026-02-21 22:32:55.608307686 +0000
@@ -16,7 +16,10 @@
 };
 
 export type CollectorContext = {
+  // siteCode is the logical "location" key. When hutCode is available, the API can resolve
+  // the current site automatically (preferred).
   siteCode: string;
+  hutCode?: string;
   agentId: string;
   nowIso: () => string;
   log: (msg: string, extra?: any) => void;
diff -ruN /mnt/data/orig/packages/api/src/routes/heartbeat.ts /mnt/data/inspect/packages/api/src/routes/heartbeat.ts
--- /mnt/data/orig/packages/api/src/routes/heartbeat.ts	2026-02-18 18:10:26.000000000 +0000
+++ /mnt/data/inspect/packages/api/src/routes/heartbeat.ts	1970-01-01 00:00:00.000000000 +0000
@@ -1,38 +0,0 @@
-// packages/api/src/routes/heartbeat.ts
-import { HeartbeatBody } from '@ops/shared'
-import type { FastifyInstance } from 'fastify'
-import { requireIngestKey } from './_auth.js'
-
-export const registerHeartbeatRoutes = async (app: FastifyInstance) => {
-  app.post('/v1/heartbeat', async (req, reply) => {
-    const parsed = HeartbeatBody.safeParse(req.body)
-    if (!parsed.success) return reply.code(400).send(parsed.error.flatten())
-
-    const body = parsed.data
-
-    if (!(await requireIngestKey(app, req, body.siteCode))) {
-      return reply.code(401).send({ error: 'unauthorized' })
-    }
-
-    const site = await app.prisma.site.upsert({
-      where: { code: body.siteCode },
-      create: {
-        code: body.siteCode,
-        type: 'UNKNOWN',
-        timezone: 'America/Denver'
-      },
-      update: {}
-    })
-
-    await app.prisma.heartbeat.create({
-      data: {
-        siteId: site.id,
-        ts: new Date(body.ts),
-        agentId: body.agentId,
-        meta: body.meta ?? undefined
-      }
-    })
-
-    return reply.send({ ok: true })
-  })
-}
diff -ruN /mnt/data/orig/packages/api/src/routes/ingest.ts /mnt/data/inspect/packages/api/src/routes/ingest.ts
--- /mnt/data/orig/packages/api/src/routes/ingest.ts	2026-02-18 18:26:42.000000000 +0000
+++ /mnt/data/inspect/packages/api/src/routes/ingest.ts	2026-02-21 22:32:41.068029963 +0000
@@ -31,28 +31,70 @@
 }
 
 export const ingestRoutes: FastifyPluginAsync = async (app) => {
+  const resolveSiteFromHut = async (hutCode: string) => {
+    const hut = await app.prisma.hut.findUnique({
+      where: { code: hutCode },
+      select: { id: true }
+    })
+    if (!hut) return { error: 'hut_not_found' as const }
+
+    const assignment = await app.prisma.hutAssignment.findFirst({
+      where: { hutId: hut.id, endsAt: null },
+      select: { site: { select: { id: true, code: true } } }
+    })
+    if (!assignment) return { error: 'hut_unassigned' as const }
+
+    return {
+      siteId: assignment.site.id,
+      siteCode: assignment.site.code
+    }
+  }
+
   app.post('/heartbeat', async (req, reply) => {
     const parsed = HeartbeatBody.safeParse(req.body)
     if (!parsed.success) return reply.code(400).send(parsed.error.flatten())
 
-    const { siteCode, agentId, ts, meta } = parsed.data
+    const { siteCode, hutCode, agentId, ts, meta } = parsed.data
+
+    // Prefer hutCode routing (stable) over siteCode routing.
+    const routed = hutCode
+      ? await resolveSiteFromHut(hutCode)
+      : { siteCode: siteCode!, siteId: null as string | null }
+
+    if ('error' in routed) {
+      return reply.code(409).send({ error: routed.error })
+    }
+
+    const effectiveSiteCode = routed.siteCode
 
-    if (!(await requireIngestKey(app, req, siteCode))) {
+    if (!(await requireIngestKey(app, req, effectiveSiteCode))) {
       return reply.code(401).send({ error: 'unauthorized' })
     }
 
-    const site = await app.prisma.site.upsert({
-      where: { code: siteCode },
-      update: {},
-      create: { code: siteCode, type: 'UNKNOWN', timezone: 'America/Denver' }
-    })
+    // Resolve / create the site
+    const site = routed.siteId
+      ? await app.prisma.site.findUniqueOrThrow({
+          where: { id: routed.siteId }
+        })
+      : await app.prisma.site.upsert({
+          where: { code: effectiveSiteCode },
+          update: {},
+          create: {
+            code: effectiveSiteCode,
+            type: 'UNKNOWN',
+            timezone: 'America/Denver'
+          }
+        })
 
     await app.prisma.heartbeat.create({
       data: {
         siteId: site.id,
         agentId,
         ts: new Date(ts),
-        meta: meta ?? undefined
+        meta: {
+          ...(meta ?? {}),
+          ...(hutCode ? { hutCode } : {})
+        }
       }
     })
 
@@ -63,17 +105,35 @@
     const parsed = IngestBatch.safeParse(req.body)
     if (!parsed.success) return reply.code(400).send(parsed.error.flatten())
 
-    const { siteCode, devices, metrics } = parsed.data
+    const { siteCode, hutCode, devices, metrics } = parsed.data
+
+    const routed = hutCode
+      ? await resolveSiteFromHut(hutCode)
+      : { siteCode: siteCode!, siteId: null as string | null }
 
-    if (!(await requireIngestKey(app, req, siteCode))) {
+    if ('error' in routed) {
+      return reply.code(409).send({ error: routed.error })
+    }
+
+    const effectiveSiteCode = routed.siteCode
+
+    if (!(await requireIngestKey(app, req, effectiveSiteCode))) {
       return reply.code(401).send({ error: 'unauthorized' })
     }
 
-    const site = await app.prisma.site.upsert({
-      where: { code: siteCode },
-      update: {},
-      create: { code: siteCode, type: 'UNKNOWN', timezone: 'America/Denver' }
-    })
+    const site = routed.siteId
+      ? await app.prisma.site.findUniqueOrThrow({
+          where: { id: routed.siteId }
+        })
+      : await app.prisma.site.upsert({
+          where: { code: effectiveSiteCode },
+          update: {},
+          create: {
+            code: effectiveSiteCode,
+            type: 'UNKNOWN',
+            timezone: 'America/Denver'
+          }
+        })
 
     // ✅ NEW: prefetch existing device meta so we can MERGE instead of clobber
     const incomingExternalIds = Array.from(
diff -ruN /mnt/data/orig/packages/shared/src/schema/ingest.ts /mnt/data/inspect/packages/shared/src/schema/ingest.ts
--- /mnt/data/orig/packages/shared/src/schema/ingest.ts	2026-02-17 16:36:11.000000000 +0000
+++ /mnt/data/inspect/packages/shared/src/schema/ingest.ts	2026-02-21 22:31:48.220507708 +0000
@@ -17,9 +17,18 @@
 export type IngestMetric = z.infer<typeof IngestMetric>
 
 export const IngestBatch = z.object({
-  siteCode: z.string().min(1),
+  // Either hutCode OR siteCode must be present.
+  siteCode: z.string().min(1).optional(),
+  hutCode: z.string().min(1).optional(),
   agentId: z.string().min(1),
   devices: z.array(IngestDevice).default([]),
   metrics: z.array(IngestMetric).min(1)
+}).superRefine((v, ctx) => {
+  if (!v.siteCode && !v.hutCode) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: 'Either siteCode or hutCode is required'
+    })
+  }
 })
 export type IngestBatch = z.infer<typeof IngestBatch>
diff -ruN /mnt/data/orig/packages/shared/src/schema/site.ts /mnt/data/inspect/packages/shared/src/schema/site.ts
--- /mnt/data/orig/packages/shared/src/schema/site.ts	2026-02-17 22:31:24.000000000 +0000
+++ /mnt/data/inspect/packages/shared/src/schema/site.ts	2026-02-21 22:31:31.938348828 +0000
@@ -14,10 +14,20 @@
  * - agentId: the agent identity (e.g. bulldog-26)
  */
 export const HeartbeatBody = z.object({
-  siteCode: z.string().min(1),
+  // Either hutCode OR siteCode must be present.
+  // Best practice: agents send hutCode and the API resolves the current site via assignment.
+  siteCode: z.string().min(1).optional(),
+  hutCode: z.string().min(1).optional(),
   agentId: z.string().min(1),
   ts: z.string().datetime(),
   siteType: SiteType.optional().default('UNKNOWN'),
   meta: z.record(z.any()).optional()
+}).superRefine((v, ctx) => {
+  if (!v.siteCode && !v.hutCode) {
+    ctx.addIssue({
+      code: z.ZodIssueCode.custom,
+      message: 'Either siteCode or hutCode is required'
+    })
+  }
 })
 export type HeartbeatBody = z.infer<typeof HeartbeatBody>
diff -ruN /mnt/data/orig/packages/web/components/hut/HutDashboard.tsx /mnt/data/inspect/packages/web/components/hut/HutDashboard.tsx
--- /mnt/data/orig/packages/web/components/hut/HutDashboard.tsx	2026-02-20 19:53:26.649308717 +0000
+++ /mnt/data/inspect/packages/web/components/hut/HutDashboard.tsx	2026-02-21 22:35:33.810814116 +0000
@@ -202,11 +202,37 @@
     }
   }, [miners, unitMode])
 
-  const stale = useMemo(() => {
-    if (!lastUpdated) return false
-    const ageMs = Date.now() - lastUpdated.getTime()
-    return ageMs > 90_000
-  }, [lastUpdated])
+  // "Last data" is based on miner timestamps, not when the page last fetched.
+  const dataUpdatedAt = useMemo(() => {
+    let best = 0
+    for (const m of miners) {
+      const t = m.ts ? Date.parse(m.ts) : NaN
+      if (Number.isFinite(t)) best = Math.max(best, t)
+    }
+    return best ? new Date(best) : null
+  }, [miners])
+
+  const dataAgeMs = useMemo(() => {
+    if (!dataUpdatedAt) return null
+    return Date.now() - dataUpdatedAt.getTime()
+  }, [dataUpdatedAt])
+
+  const ageLabel = useMemo(() => {
+    if (dataAgeMs == null) return '—'
+    const s = Math.floor(dataAgeMs / 1000)
+    if (s < 60) return `${s}s ago`
+    const m = Math.floor(s / 60)
+    if (m < 60) return `${m}m ago`
+    const h = Math.floor(m / 60)
+    return `${h}h ago`
+  }, [dataAgeMs])
+
+  const ageTone: 'ok' | 'warn' | 'crit' | 'muted' = useMemo(() => {
+    if (dataAgeMs == null) return 'muted'
+    if (dataAgeMs > 10 * 60_000) return 'crit'
+    if (dataAgeMs > 3 * 60_000) return 'warn'
+    return 'ok'
+  }, [dataAgeMs])
 
   return (
     <div className='min-h-screen'>
@@ -227,19 +253,23 @@
                 {source}
               </Badge>
 
-              {stale ? (
-                <Badge tone='warn'>
-                  <Clock className='h-3.5 w-3.5' />
-                  STALE
-                </Badge>
-              ) : null}
+              <Badge tone={ageTone}>
+                <Clock className='h-3.5 w-3.5' />
+                {ageLabel}
+              </Badge>
 
               <span className='text-xs text-zinc-600'>
-                {lastUpdated
-                  ? `Updated ${lastUpdated.toLocaleTimeString()}`
-                  : '—'}
+                {dataUpdatedAt
+                  ? `Last data ${dataUpdatedAt.toLocaleTimeString()}`
+                  : 'No data yet'}
               </span>
 
+              {lastUpdated ? (
+                <span className='text-xs text-zinc-700'>
+                  Fetched {lastUpdated.toLocaleTimeString()}
+                </span>
+              ) : null}
+
               <Button
                 variant='ghost'
                 className='px-3 py-1.5'
